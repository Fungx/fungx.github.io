---
title: 【未完成】System Design Interview 笔记——1.邻近服务
date: 2025-06-18 01:51:00 +0800
categories: [Golang]
tags: [system design]     # TAG names should always be lowercase
---
本章中，我们将设计一个邻近服务(Proximity Service). 邻近服务用于发现用户附近的商家，比如餐馆、酒店等等。
# 第一步 - 理解问题并确定设计范围
> 在收到需求后，可以先大胆向面试官提问，理清楚面试官脑海中的实际需求以及对系统的预期目标。
>
> 面试中的系统设计不可能面面俱到。通过提问，也可以缩小需要设计的范围。
>
> 作为参考，下面记录本章的问答示例，后面的章节不再记录。

|候选人提问|面试官回答|
|--|--|
|用户可以设定搜索半径吗？如果半径内没有足够的商家，系统会扩大搜索吗？|假设只考虑固定半径内的商家。如果时间足够，再讨论没有半径内足够对象的商家。|
|允许的最大半径是多少？可以假设为 20km 吗？|可以。|
|用户可以在 UI 上改变搜索半径吗？|可以。我们有以下选项 0.5km, 1km, 2km, 5km 和 20km|
|商家信息可以被添加、删除、更新吗？这些操作需要被实时反应吗？|商家信息可以被进行这些操作。假设添加、更新的商家信息需要在第二天生效。|
|用户可能在使用时移动，搜索结果会有变化。我们需要刷新用户页面，确保结果是最新的吗？|假设用户移动很慢，不需要实时刷新页面|。

## 功能性需求
- 根据用户的位置与搜索半径，返回所有商家
- 商家可以添加、删除、更新商家信息，但这些信息不需要立刻生效
- 用户可以查看商家的详情
  
## 非功能需求
- 低延迟。用户希望搜索结果能快速返回。
- 数据隐私。位置信息是敏感数据，需要保证数据保存和使用合规。(注：在本章的内容中，实际没什么体现，感觉更需要与现实场景结合。)
- 高可用与扩展性。需要确保我们的系统可以抗住人口密集区域的流量高峰。

## 容量估算
假设我们有 100M 日活跃用户和 200M 商家（注：感觉这个数字有点奇怪，一般商家应该远少于日活用户吧）。

下面我们计算系统的 QPS
- 一天有 $24 \times 60 \times 60= 86,400$ 秒，为了方便计算，取整为 $10^5$ 秒。
- 假设一个用户每天搜索 5 次。
- 搜索 $QPS = \frac{100M \times 5}{10^5}= 5,000$.

# 第二步 - 提出高层设计并得到认同
## API 设计

我们使用 RESTful API 的习惯进行设计。

### GET /v1/search/nearby

这个接口返回了基于特定搜索范围的商家。在实际应用中，搜索结果通常是**分页**的

请求参数:
- latitude, 位置的纬度
- longitude, 位置的经度
- radius, (可选) 搜索半径,默认3米

返回示例:
```
{
    "total": 10,
    "bussinesses": [{business object}]
}
``` 

business object 里包含了渲染搜索结果页需要的所有东西。

> 关于如何设计 RESTfule API 的分页，书中提供了一份[参考文档](https://developer.atlassian.com/server/confluence/pagination-in-the-rest-api).
>
> 核心设计思路是2点：
> 1. 查询接口需要支持传入对页数、数量的限制，可以让调用者有查询“下一页”的能力。
> 例如 http://localhost:8080/confluence/rest/api/space/ds/content/page?limit=5&start=10
> 
> 2. 返回结果需要让调用者知道，是否还有更多内容。例如返回结果中，将`_links`中的`next`链接置空，表示不能再获取下一页了。或者，调用者请求 5 个结果，但只返回了 4 个，也可以让对方感知到后面已经没有数据了。 


### 商家 API

对 bussiness object 的操作 API有以下几个：
- GET /v1/bussines/:id 返回一个商家的详情
- POST /v1/bussines 添加一个商家
- PUT /v1/bussines/:id 更新一个商家的详情
- DELETE /v1/bussines/:id 删除一个商家

## 数据模型
这一节会讨论读/写比例以及模式设计。

### 读/写比例
因为“搜索附近的商家”和“查看商家的详情”这两个功能的使用频率很高，显然，我们的读请求是更多的。
另一方面，因为对商家信息的增删改不是常见的操作，写请求是更少的。

对于一个**读多写少**的系统，类似 MySQL 之类的关系型数据库是很好的工具。

### 数据模式
关键的数据表有 商家表 和 地理空间(geo)索引表。
- 商家表，以 bussiness_id 为主键，表中包含了所有相关的详情信息。
- geo 索引表用于高效地执行空间操作。由于这里涉及 geohash，会在「数据库扩容」一节讨论。

### 高层设计
![架构图](/assets/system-design-interview/high-level-design.png)

#### 负载均衡器
负载均衡器自动将入流量分发到多个服务上。一般，公司内会提供 DNS 来完成路由，并根据 URL 将请求打到不同的服务上。

#### LBS
LBS 根据一个给定的半径和位置，查找附近的商家。
- 读负载高，没有写负载。
- QPS 高。
- 无状态，因而可以轻易地水平扩容。

#### 商家服务
商家服务处理 2 类请求：商家对商家信息的增删改查，QPS 低；用户查询商家详情，QPS 高。

#### 数据库集群
数据库使用主从模式。主库处理写操作，多个从库处理读操作。在这种模式中，主库把数据保存后，复制到从库。由于主从间存在延迟，读取偶尔会出现不一致。但在我们的场景中是可接受的

#### 商家服务与 LBS 的可扩展性
商家服务与 LBS 都是无状态的服务，因此可以简单地在高峰/低谷期水平扩容/缩容。

### 搜索附近商家的算法
#### 二维搜索
最符合直觉的和简单的方式是在当前位置画一个圈，然后搜索圈里的所有商家。
这个过程可以翻译成下面的伪 SQL 查询.

``` SQL
SELECT business_id, latitude, longitude,
FROM bussiness
WHERE (latitude BETWEEN {:my_lat} - radius AND {:my_lat} + radius)
AND (longitude BETWEEN {:my_long} - radius AND {:my_long} + radius)
```

这个查询存在一些问题：搜索效率低，需要全表扫描。即使我们给经度和纬度建立了索引，效率也不会提升太多。问题在于我们需要二维的数据，而每一维返回的数据量依然很大。如下图，通过索引可以快速找到符合经度和纬度的所有数据，而求出他们的交集依然是个效率很低的操作，因为数据量太大了。
![alt text](/assets/system-design-interview//intersect.png)

**问题根因：数据库索引只能提升一个维度的搜索速度。**

由此可以引出另一个思路：能否将二维的数据映射到一维？

下图展示了是 2 类地理空间信息的索引方式。他们的核心思想都是一样的：**把地图划分为更小的区域，构建索引来快速搜索。**
![alt text](/assets/system-design-interview/geo-indexes.png)


#### 均分格子
一种简单的方法是把世界均分为相等大小的格子，每个格子都包含多个商家，每个商家都属于一个格子。
但是，商家的分布不是均匀的。大城市的商家更多，而大洋某个位置上却不会有商家。这种方式产生了非常不均匀的数据分布。

> 数据不均匀会有什么问题？
> 
> 负载不均：大城市商区的商家密度更高，人流也更多。意味着热点格子需要承担更多的请求，大量的请求都会打到一个分区上，产生热点问题。

#### Geohash

